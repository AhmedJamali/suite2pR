import os
import suite2p 
import shutil
import numpy as np 

from pathlib import Path
from conftest import initialize_ops #Guarantees that tests and this script use the same ops
from tests.regression.utils import FullPipelineTestUtils, DetectionTestUtils
from suite2p.extraction import masks

current_dir = Path(os.getcwd())
# Assumes the input file has already been downloaded
test_input_dir_path = current_dir.parent.joinpath('data').joinpath('test_data')
# Output directory where suite2p results are kept
test_data_dir_path =  current_dir.joinpath('test_data')

class GenerateFullPipelineTestData:
	# Full Pipeline Tests
	def generate_1p1c1500_expected_data(ops):
		"""
		Generates expected output for test_1plane_1chan_with_batches_metrics_and_exported_to_nwb_format
		for test_full_pipeline.py
		"""
		test_ops = FullPipelineTestUtils.initialize_ops_test1plane_1chan_with_batches(ops.copy())
		suite2p.run_s2p(ops=test_ops)
		rename_output_dir('1plane1chan1500')

	# def generate_1p2c_expected_data(ops):
	#   """
	#   Generates expected output for test_1plane_2chan_sourcery of test_full_pipeline.py.
	#   """
	#   test_ops = FullPipelineTestUtils.initialize_ops_test_1plane_2chan_sourcery(ops.copy())
	#   suite2p.run_s2p(ops=test_ops)
	#   rename_output_dir('1plane2chan')

	def generate_2p2c1500_expected_data(ops):
		"""
		Generates expected output for test_2plane_2chan_with_batches of test_full_pipeline.py.
		"""
		test_ops = FullPipelineTestUtils.initialize_ops_test2plane_2chan_with_batches(ops.copy())
		suite2p.run_s2p(ops=test_ops)
		rename_output_dir('2plane2chan1500')

	def generate_2p2zmesoscan_expected_data(ops):
		"""
		Generates expected output for test_mesoscan_2plane_2z of test_full_pipeline.py.
		"""
		test_ops = FullPipelineTestUtils.initialize_ops_test_mesoscan_2plane_2z(ops.copy())
		suite2p.run_s2p(ops=test_ops)
		rename_output_dir('mesoscan')

	def generate_all_data(full_ops):
		# Expected Data for test_full_pipeline.py
		GenerateFullPipelineTestData.generate_1p1c1500_expected_data(full_ops)
		# generate_1p2c_expected_data(ops)
		GenerateFullPipelineTestData.generate_2p2c1500_expected_data(full_ops)
		GenerateFullPipelineTestData.generate_2p2zmesoscan_expected_data(full_ops)

class GenerateDetectionTestData:
	# Detection Tests
	def generate_detection_1plane1chan_test_data(ops):
		"""
		Generates expected output for test_detection_output_1plane1chan of test_detection_pipeline.py.
		"""
		# Use only the smaller input tif
		ops.update({
			'tiff_list': ['input.tif'],
		})
		ops = DetectionTestUtils.prepare(
			ops,
			[[Path(ops['data_path'][0]).joinpath('detection/pre_registered.npy')]],
			(404, 360)
		)
		ops, stat = suite2p.detection.detect(ops[0])
		cell_masks = masks.create_masks(stat, ops['Ly'], ops['Lx'], ops=ops)[0]
		output_dict = {
			'stat': stat,
			'cell_masks': cell_masks
		}
		np.save('expected_detect_output_1p1c0.npy', output_dict)
		# Remove suite2p directory generated by prepare function
		shutil.rmtree(os.path.join(test_data_dir_path, 'suite2p'))

	def generate_detection_2plane2chan_test_data(ops):
		ops.update({
			'tiff_list': ['input.tif'],
		})
		ops.update({
			'nchannels': 2,
			'nplanes': 2,
		})
		detection_dir = Path(ops['data_path'][0]).joinpath('detection')
		two_plane_ops = DetectionTestUtils.prepare(
			ops,
			[
				[detection_dir.joinpath('pre_registered01.npy'), detection_dir.joinpath('pre_registered02.npy')],
				[detection_dir.joinpath('pre_registered11.npy'), detection_dir.joinpath('pre_registered12.npy')]
			]
			, (404, 360),
		)
		two_plane_ops[0]['meanImg_chan2'] = np.load(detection_dir.joinpath('meanImg_chan2p0.npy'))
		two_plane_ops[1]['meanImg_chan2'] = np.load(detection_dir.joinpath('meanImg_chan2p1.npy'))
		for i in range(len(two_plane_ops)):
			op = two_plane_ops[i]
			op, stat = suite2p.detection.detect(ops=op)
			cell_masks = masks.create_masks(stat, op['Ly'], op['Lx'], ops=op)[0]
			output_dict = {
				'stat': stat,
				'cell_masks': cell_masks
			}
			np.save('expected_detect_output_%ip%ic%i.npy' % (ops['nchannels'], ops['nplanes'], i), output_dict)
	
	def generate_all_data(ops):
		GenerateDetectionTestData.generate_detection_1plane1chan_test_data(ops)
		GenerateDetectionTestData.generate_detection_2plane2chan_test_data(ops)
		rename_output_dir('detection')
		# Move over expected outputs into detection
		shutil.move('expected_detect_output_1p1c0.npy', test_data_dir_path.joinpath('detection'))
		shutil.move('expected_detect_output_2p2c0.npy', test_data_dir_path.joinpath('detection'))
		shutil.move('expected_detect_output_2p2c1.npy', test_data_dir_path.joinpath('detection'))

class GenerateClassificationTestData:
	# Classification Tests
	def generate_classification_test_data(ops):
		stat = np.load(test_input_dir_path.joinpath('classification/pre_stat.npy'), allow_pickle=True)
		iscell = suite2p.classification.classify(stat, classfile=suite2p.classification.builtin_classfile)
		np.save('expected_classify_output_1p1c0.npy', iscell)

	def generate_all_data(ops):
		GenerateClassificationTestData.generate_classification_test_data(ops)
		make_new_dir(test_data_dir_path.joinpath('classification'))
		shutil.move('expected_classify_output_1p1c0.npy', test_data_dir_path.joinpath('classification'))

def rename_output_dir(new_dir_name):
	curr_dir_path = os.path.abspath(os.getcwd())
	new_dir_path = os.path.join(test_data_dir_path, new_dir_name)
	if os.path.exists(new_dir_path):
		shutil.rmtree(new_dir_path)
	os.makedirs(new_dir_path)
	shutil.move(os.path.join(test_data_dir_path, 'suite2p'), new_dir_path)

def make_new_dir(new_dir_name):
	if not os.path.exists(new_dir_name):
		os.makedirs(new_dir_name)
		print('Created test directory at ' + str(new_dir_name))

def main():
	#Create test_data directory if necessary
	make_new_dir(test_data_dir_path)
	full_ops = initialize_ops(test_data_dir_path, test_input_dir_path)
	#GenerateFullPipelineTestData.generate_all_data(full_ops)
	det_ops = initialize_ops(test_data_dir_path, test_input_dir_path)
	#GenerateDetectionTestData.generate_all_data(det_ops)
	GenerateClassificationTestData.generate_all_data(full_ops)
	return 

if __name__ == '__main__':
	main()
